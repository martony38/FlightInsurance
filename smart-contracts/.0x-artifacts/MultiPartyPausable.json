{
	"schemaVersion": "2.0.0",
	"contractName": "MultiPartyPausable",
	"compilerOutput": {
		"abi": [
			{
				"constant": false,
				"inputs": [],
				"name": "unpause",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "account",
						"type": "address"
					}
				],
				"name": "isPauser",
				"outputs": [
					{
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "paused",
				"outputs": [
					{
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [],
				"name": "renouncePauser",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "account",
						"type": "address"
					}
				],
				"name": "addPauser",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [],
				"name": "pause",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"name": "requiredPausers",
						"type": "uint8"
					}
				],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"name": "account",
						"type": "address"
					}
				],
				"name": "Paused",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"name": "account",
						"type": "address"
					}
				],
				"name": "Unpaused",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"name": "account",
						"type": "address"
					}
				],
				"name": "PauserAdded",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"name": "account",
						"type": "address"
					}
				],
				"name": "PauserRemoved",
				"type": "event"
			}
		],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			},
			"deployedBytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			}
		}
	},
	"sources": {
		"MultiPartyPausable.sol": {
			"id": 5
		},
		"@openzeppelin/contracts/GSN/Context.sol": {
			"id": 6
		},
		"@openzeppelin/contracts/access/roles/PauserRole.sol": {
			"id": 8
		},
		"@openzeppelin/contracts/access/Roles.sol": {
			"id": 7
		}
	},
	"sourceCodes": {
		"MultiPartyPausable.sol": "pragma solidity >=0.4.21 <0.6.0;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/access/roles/PauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by m of n authorized accounts.\n * Inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/lifecycle/Pausable.sol\n */\ncontract MultiPartyPausable is Context, PauserRole {\n    /*************************************************************************/\n    /*                            DATA VARIABLES                             */\n    /*************************************************************************/\n    bool private _paused;\n\n    // List of admins that have toggled pause\n    address[] private _toggledPausers;\n\n    // Treshold to reach multi-party consensus to toggle pause\n    uint8 private _requiredPausers;\n\n    /*************************************************************************/\n    /*                           EVENT DEFINITIONS                           */\n    /*************************************************************************/\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    /*************************************************************************/\n    /*                              CONSTRUCTOR                              */\n    /*************************************************************************/\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor(uint8 requiredPausers) internal {\n        _paused = false;\n        _requiredPausers = requiredPausers;\n    }\n\n    /*************************************************************************/\n    /*                          FUNCTION MODIFIERS                           */\n    /*************************************************************************/\n    /**\n     * @dev Modifier to make a function callable only when the contract is not\n     * paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is\n     * paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    modifier notDuplicate() {\n        for (uint8 c = 0; c < _toggledPausers.length; c++) {\n            require(\n                _toggledPausers[c] != _msgSender(),\n                \"Caller has already called this function.\"\n            );\n        }\n        _;\n    }\n\n    /*************************************************************************/\n    /*                           UTILITY FUNCTIONS                           */\n    /*************************************************************************/\n\n    /*************************************************************************/\n    /*                       SMART CONTRACT FUNCTIONS                        */\n    /*************************************************************************/\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused notDuplicate {\n        _toggledPausers.push(_msgSender());\n        if (_toggledPausers.length >= _requiredPausers) {\n            _paused = true;\n            _toggledPausers = new address[](0);\n            emit Paused(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused notDuplicate {\n        _toggledPausers.push(_msgSender());\n        if (_toggledPausers.length >= _requiredPausers) {\n            _paused = false;\n            _toggledPausers = new address[](0);\n            emit Unpaused(_msgSender());\n        }\n    }\n\n}\n",
		"@openzeppelin/contracts/GSN/Context.sol": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they not should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, with should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n",
		"@openzeppelin/contracts/access/roles/PauserRole.sol": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract PauserRole is Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(_msgSender());\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n",
		"@openzeppelin/contracts/access/Roles.sol": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
	},
	"sourceTreeHashHex": "0x58f7304327aeda3bd1dd4ba57ed908837cf3cacf7c14c6b608bd14d2aecdcf9b",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.8+commit.23d335f2.js",
		"settings": {
			"optimizer": {
				"enabled": false
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object",
						"evm.deployedBytecode.object"
					]
				}
			},
			"remappings": [
				"@openzeppelin/contracts=/Users/laurent/Repos/Udacity/Nanodegrees/Blockchain Developer/Project 6/smart-contracts/node_modules/@openzeppelin/contracts"
			]
		}
	},
	"networks": {}
}